"""
AI-Powered Query Interpreter for Healthcare Search
Intelligently parses user queries and maps them to FHIR API parameters
"""

import openai
import json
import os
from typing import Dict, List, Any, Optional
import re

class AIQueryInterpreter:
    def __init__(self):
        # Use XAI (Grok) instead of OpenAI
        xai_api_key = os.getenv("XAI_API_KEY")
        if not xai_api_key:
            raise ValueError("XAI_API_KEY environment variable is required")
        
        self.openai_client = openai.OpenAI(
            api_key=xai_api_key,
            base_url="https://api.x.ai/v1"
        )
        self.fhir_context = self._load_fhir_context()
    
    def _load_fhir_context(self) -> str:
        """Load FHIR API context for the AI to understand available parameters"""
        return """
FHIR API Context for French Healthcare Directory:

ORGANIZATION SEARCH (https://gateway.api.esante.gouv.fr/fhir/Organization):
- name: Organization name (use specific organization names, avoid generic terms like "hôpital")
- address-city: City name (preferred over postal codes for broader search)
- address-postalcode: Postal code (75001, 13001, etc.)
- type: Organization type
- active: true/false
- _count: Number of results
- NOTE: Generic terms like "hôpital", "clinique" in name parameter cause timeouts. Use city-based search instead.

PRACTITIONER SEARCHES:
1. BY SPECIALTY (PractitionerRole): Use role parameter for profession-based searches
   - role: Profession code (40=kinésithérapeute, 60=médecin, 86=dentiste, 31=sage-femme, 96=pharmacien, 50=ostéopathe, 23=infirmier, 95=spécialiste)
   - address-postalcode: Postal code
   - address-city: City name (local filtering)
   - _count: Number of results
   
2. BY NAME (Practitioner): Use name parameters for name-based searches  
   - name: Full name search
   - family: Last name only
   - given: First name only
   - _count: Number of results

MEDICATION SEARCH (API-BDPM GraphQL):
- search_type: "name" | "substance" | "cis_code"
- query: Medication name, substance name, or CIS code
- limit: Number of results (default 10)
- Available information: denomination, pharmaceutical form, administration route, 
  reimbursement status, price, active substances, presentations

FRENCH CONTEXT:
- Paris arrondissements: 1er, 2e, ..., 20e → 75001, 75002, ..., 75020
- Common terms: hôpital=hospital, clinique=clinic, cabinet=practice, centre médical=medical center
- Specialties: cardiologue=cardiologist, dentiste=dentist, sage-femme=midwife, etc.
- Medications: médicament=medication, medicament=drug, substance=active ingredient, prix=price, remboursement=reimbursement
- IMPORTANT: For organization searches, prefer geographic filters over generic type names

MEDICATION SEARCH CONTEXT:
- Medication queries: "find Doliprane", "what is Aspirin", "paracetamol information", "médicament Doliprane"
- Substance queries: "medications with paracetamol", "drugs containing aspirin", "médicaments avec paracétamol"
- Price queries: "cost of Doliprane", "remboursement for antibiotics", "prix Doliprane"
- CIS code queries: "CIS 60009011", "medication with CIS code"
- The system can search by medication name, active substance, or CIS code
"""

    async def interpret_query(self, user_query: str) -> Dict[str, Any]:
        """
        Use AI to intelligently interpret user query and generate search strategy
        """
        
        system_prompt = f"""You are an intelligent healthcare search interpreter for France. 
Your job is to analyze user queries and determine the best search strategy.

{self.fhir_context}

Analyze the user query and return a JSON response with this structure:
{{
    "intent": "organization" | "practitioner" | "medication" | "mixed",
    "confidence": 0.0-1.0,
    "extracted_entities": {{
        "entity_type": ["hospital", "clinic", "doctor", "specialist", "medication", "substance", etc.],
        "specialty": "extracted medical specialty if any",
        "location": {{
            "city": "city name if mentioned",
            "postal_code": "postal code if extractable",
            "arrondissement": "Paris arrondissement if mentioned"
        }},
        "organization_name": "specific name if mentioned",
        "practitioner_name": "specific name if mentioned",
        "medication_name": "medication name if mentioned",
        "substance_name": "active substance if mentioned", 
        "cis_code": "CIS code if mentioned",
        "count": "number if user specified how many results"
    }},
    "search_strategy": {{
        "primary": "organization" | "practitioner" | "medication",
        "fallback": "organization" | "practitioner" | "medication" | null,
        "parallel": true | false
    }},
    "fhir_params": {{
        "organization": {{
            "name": "value or null",
            "address-city": "value or null", 
            "address-postalcode": "value or null",
            "_count": "number"
        }},
        "practitioner": {{
            "specialty": "value or null",
            "address-city": "value or null",
            "address-postalcode": "value or null", 
            "_count": "number"
        }},
        "medication": {{
            "search_type": "name" | "substance" | "cis_code",
            "query": "medication name, substance, or CIS code",
            "limit": "number of results"
        }}
    }},
    "reasoning": "Brief explanation of your interpretation"
}}

Handle French language naturally. Convert Paris arrondissements to postal codes.
Be intelligent about ambiguous queries - use context clues.
"""

        try:
            response = await self.openai_client.chat.completions.acreate(
                model="grok-2-1212",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"Query: {user_query}"}
                ],
                temperature=0.1,
                max_tokens=1000
            )
            
            result_text = response.choices[0].message.content
            
            # Parse the JSON response
            try:
                # Handle JSON wrapped in code blocks
                content = result_text.strip()
                if content.startswith('```json'):
                    # Extract JSON from code block
                    lines = content.split('\n')
                    json_lines = []
                    in_json = False
                    for line in lines:
                        if line.strip() == '```json':
                            in_json = True
                            continue
                        elif line.strip() == '```' and in_json:
                            break
                        elif in_json:
                            json_lines.append(line)
                    content = '\n'.join(json_lines)
                
                result = json.loads(content)
                print(f"[AI_DEBUG] Interpreted query: {user_query}")
                print(f"[AI_DEBUG] Result: {result}")
                return result
            except json.JSONDecodeError as e:
                print(f"[AI_ERROR] Failed to parse AI response: {e}")
                print(f"[AI_ERROR] Raw response: {result_text}")
                return self._fallback_interpretation(user_query)
                
        except Exception as e:
            print(f"[AI_ERROR] AI interpretation failed: {e}")
            return self._fallback_interpretation(user_query)
    
    def _validate_and_fix_medication_query(self, query: str, ai_result: Dict[str, Any]) -> Dict[str, Any]:
        """
        Validate AI medication results and fix common issues like:
        - Generic terms that don't exist in ANSM database  
        - Use medical condition mapping to find actual medication names
        """
        query_lower = query.lower()
        
        # Get the AI's medication name
        medication_name = ai_result.get('extracted_entities', {}).get('medication_name', '')
        if not medication_name:
            medication_name = ai_result.get('fhir_params', {}).get('medication', {}).get('query', '')
        
        # Check if this is a generic term that needs mapping
        generic_terms = [
            'médicament pour mieux dormir', 'somnifère', 'sleeping pill',
            'anti-inflammatoire', 'antalgique', 'analgesic',
            'anxiolytique', 'laxatif', 'antitussif'
        ]
        
        medication_needs_mapping = False
        if medication_name.lower() in [term.lower() for term in generic_terms]:
            medication_needs_mapping = True
            print(f"[AI_FIX] Generic term detected: '{medication_name}' - applying medical mapping")
        
        # Apply medical condition mapping if needed
        if medication_needs_mapping or not medication_name:
            # Medical condition mapping (same as fallback logic)
            medical_condition_mapping = {
                # Sleep conditions - use actual medication names from ANSM
                'dormir': 'melatonine',  # ✅ 3 results in ANSM
                'sommeil': 'melatonine', 
                'somnifère': 'melatonine',  # Map generic term to actual medication
                'insomnie': 'zolpidem',  # ✅ 2 results in ANSM
                # Pain and inflammation
                'maux de tête': 'doliprane',  # ✅ 10 results working
                'mal de tête': 'doliprane',
                'migraine': 'sumatriptan',  # ✅ 3 results in ANSM
                'douleur': 'paracetamol',
                'fièvre': 'paracetamol',
                'anti-inflammatoire': 'ibuprofene',  # Map generic term
                'antalgique': 'paracetamol',  # Map generic term
                # Respiratory
                'toux': 'toux',  # ✅ 2 results working
                'rhume': 'rhume',
                'antitussif': 'toux',  # Map generic term
                # Mental health
                'stress': 'valerian',  # ✅ 7 results working
                'anxiété': 'lexomil',  # ✅ 1 result in ANSM
                'anxiolytique': 'lexomil',  # Map generic term
                # Digestive - use actual medication names from ANSM
                'digestion': 'spasfon',  # ✅ 5 results working
                'constipation': 'lactulose',  # ✅ 2 results in ANSM
                'laxatif': 'lactulose',  # Map generic term
                'diarrhée': 'imodium',  # ✅ 3 results in ANSM
                'nausée': 'domperidone'  # ✅ 3 results in ANSM
            }
            
            mapped_medication = None
            for condition, french_med in medical_condition_mapping.items():
                if condition in query_lower:
                    mapped_medication = french_med
                    print(f"[AI_FIX] Mapped '{condition}' to '{french_med}'")
                    break
            
            if mapped_medication:
                # Update the AI result with the corrected medication name
                ai_result['extracted_entities']['medication_name'] = mapped_medication
                ai_result['fhir_params']['medication']['query'] = mapped_medication
                print(f"[AI_FIX] Updated medication query from '{medication_name}' to '{mapped_medication}'")
            else:
                print(f"[AI_FIX] No mapping found for query, keeping original: '{medication_name}'")
        
        return ai_result
    
    def _fallback_interpretation(self, query: str) -> Dict[str, Any]:
        """Fallback to simple rule-based interpretation if AI fails"""
        query_lower = query.lower()
        
        # Check for medication queries FIRST (highest priority)
        # Include explicit medication names, therapeutic categories, and medical conditions
        medication_keywords = [
            # Explicit medication names
            'doliprane', 'aspirin', 'aspirine', 'paracetamol', 'paracétamol', 'ibuprofen', 'ibuprofène',
            # General medication terms
            'médicament', 'medicament', 'medication', 'drug', 'substance', 'prix', 'price', 'cost',
            'remboursement', 'reimbursement', 'cis', 'posologie', 'dosage', 'effet', 'side effect',
            'contre-indication', 'contraindication', 'antibiotique', 'antibiotic',
            # Therapeutic categories
            'anti-inflammatoire', 'antiinflammatoire', 'anti-inflammatory', 'antalgique', 'analgesic',
            'antipyrétique', 'antipyretic', 'somnifère', 'sleeping pill', 'anxiolytique', 'anxiolytic',
            'antitussif', 'cough suppressant', 'expectorant', 'bronchodilatateur', 'bronchodilator',
            'antihistaminique', 'antihistamine', 'antispasmodique', 'antispasmodic',
            # Medical conditions and symptoms
            'dormir', 'sommeil', 'sleep', 'insomnie', 'insomnia', 'toux', 'cough', 'rhume', 'cold',
            'maux de tête', 'mal de tête', 'headache', 'migraine', 'douleur', 'pain', 'fièvre', 'fever',
            'stress', 'anxiété', 'anxiety', 'digestion', 'constipation', 'diarrhée', 'diarrhea',
            'nausée', 'nausea', 'vomissement', 'vomiting', 'allergie', 'allergy',
            # Pharmacy and prescription terms
            'pharmacie', 'pharmacy', 'sans ordonnance', 'over the counter', 'otc', 'vente libre',
            'prescription', 'ordonnance', 'automédication', 'self medication'
        ]
        
        # Check for medication-related terms
        is_medication_query = any(keyword in query_lower for keyword in medication_keywords)
        
        # Check for CIS code pattern
        cis_match = re.search(r'\bcis\s*(\d+)\b', query_lower)
        cis_code = cis_match.group(1) if cis_match else None
        
        if is_medication_query or cis_code:
            # Extract medication name or condition (look for specific medication names first)
            medication_name = None
            condition_or_category = None
            
            # First, look for specific medication names
            specific_medications = ['doliprane', 'aspirin', 'aspirine', 'paracetamol', 'paracétamol', 'ibuprofen', 'ibuprofène']
            for med in specific_medications:
                if med in query_lower:
                    medication_name = med.title()
                    break
            
            # If no specific medication, look for therapeutic categories and map to French terms
            if not medication_name:
                therapeutic_categories = {
                    'anti-inflammatoire': 'ibuprofene',
                    'antiinflammatoire': 'ibuprofene', 
                    'anti-inflammatory': 'ibuprofene',
                    'antalgique': 'paracetamol',
                    'analgesic': 'paracetamol',
                    'somnifère': 'somnifere',
                    'sleeping pill': 'somnifere',
                    'anxiolytique': 'anxiolytique',
                    'antitussif': 'toux',  # Search for cough medications
                    'cough suppressant': 'toux',
                    'antihistaminique': 'antihistaminique',
                    'antispasmodique': 'antispasmodique'
                }
                
                for category, generic_name in therapeutic_categories.items():
                    if category in query_lower:
                        condition_or_category = generic_name
                        break
            
            # If no medication or category, look for medical conditions and map to French equivalents
            if not medication_name and not condition_or_category:
                # Map medical conditions to actual French medication names that exist in ANSM database
                medical_condition_mapping = {
                    # Sleep conditions - use actual medication names from ANSM
                    'dormir': 'melatonine',  # ✅ 3 results in ANSM
                    'sommeil': 'melatonine', 
                    'insomnie': 'zolpidem',  # ✅ 2 results in ANSM
                    # Pain and inflammation
                    'maux de tête': 'doliprane',  # ✅ 10 results working
                    'mal de tête': 'doliprane',
                    'migraine': 'sumatriptan',  # ✅ 3 results in ANSM
                    'douleur': 'paracetamol',
                    'fièvre': 'paracetamol',
                    # Respiratory
                    'toux': 'toux',  # ✅ 2 results working
                    'rhume': 'rhume',
                    # Mental health
                    'stress': 'valerian',  # ✅ 7 results working
                    'anxiété': 'lexomil',  # ✅ 1 result in ANSM (was: anxiolytique)
                    # Digestive - use actual medication names from ANSM
                    'digestion': 'spasfon',  # ✅ 5 results working
                    'constipation': 'lactulose',  # ✅ 2 results in ANSM (was: laxatif)
                    'diarrhée': 'imodium',  # ✅ 3 results in ANSM
                    'nausée': 'domperidone'  # ✅ 3 results in ANSM
                }
                
                for condition, french_med in medical_condition_mapping.items():
                    if condition in query_lower:
                        condition_or_category = french_med
                        break
            
            # Determine search type and query
            if cis_code:
                search_type = "cis_code"
                search_query = cis_code
            elif medication_name:
                # Direct medication name search
                search_type = "name"
                search_query = medication_name
            elif condition_or_category:
                # Search by therapeutic category or condition
                if any(keyword in query_lower for keyword in ['substance', 'principe actif']):
                    search_type = "substance"
                    search_query = condition_or_category
                else:
                    search_type = "name"
                    search_query = condition_or_category
            else:
                # Fallback to generic search
                search_type = "name"
                search_query = "Doliprane"
            
            return {
                "intent": "medication",
                "confidence": 0.9,
                "extracted_entities": {
                    "entity_type": ["medication"],
                    "medication_name": medication_name,
                    "cis_code": cis_code,
                    "substance_name": search_query if search_type == "substance" else None
                },
                "search_strategy": {
                    "primary": "medication",
                    "fallback": None,
                    "parallel": False
                },
                "fhir_params": {
                    "organization": {
                        "address-city": None,
                        "address-postalcode": None,
                        "_count": None
                    },
                    "practitioner": {
                        "address-city": None,
                        "address-postalcode": None,
                        "_count": None
                    },
                    "medication": {
                        "search_type": search_type,
                        "query": search_query,
                        "limit": "10"
                    }
                },
                "reasoning": f"Fallback rule-based interpretation - detected medication search for {search_query}"
            }
        
        # Check for medical specialties FIRST (highest priority)
        specialty_keywords = {
            'kinésithérapeute': '40', 'kiné': '40', 'kine': '40', 'physiotherapist': '40',
            'ostéopathe': '50', 'osteopath': '50', 'osteopathe': '50',
            'dentiste': '86', 'dentist': '86', 'chirurgien-dentiste': '86',
            'sage-femme': '31', 'midwife': '31', 'sages-femmes': '31',
            'pharmacien': '96', 'pharmacist': '96', 'pharmacienne': '96',
            'médecin': '60', 'medecin': '60', 'generaliste': '60', 'généraliste': '60',
            'cardiologue': '95', 'cardiologist': '95',
            'dermatologue': '95', 'dermatologist': '95',
            'infirmier': '23', 'infirmière': '23', 'nurse': '23'
        }
        
        found_specialty = None
        specialty_code = None
        for keyword, code in specialty_keywords.items():
            if keyword in query_lower:
                found_specialty = keyword
                specialty_code = code
                break
        
        # Extract postal code
        postal_match = re.search(r'\b(\d{5})\b', query)
        postal_code = postal_match.group(1) if postal_match else None
        
        # Extract city
        city_match = re.search(r'\b(paris|lyon|marseille|nice|toulouse|bordeaux|nantes)\b', query_lower)
        city = city_match.group(1).title() if city_match else None
        
        # If we found a specialty, prioritize that over name detection
        if found_specialty:
            return {
                "intent": "practitioner",
                "confidence": 0.9,
                "extracted_entities": {
                    "entity_type": ["specialist"],
                    "specialty": found_specialty,
                    "location": {
                        "city": city,
                        "postal_code": postal_code
                    }
                },
                "search_strategy": {
                    "primary": "practitioner",
                    "fallback": None,
                    "parallel": False
                },
                "fhir_params": {
                    "organization": {
                        "address-city": None,
                        "address-postalcode": None,
                        "_count": None
                    },
                    "practitioner": {
                        "specialty": specialty_code,
                        "role": specialty_code,
                        "practitioner_name": None,
                        "name": None,
                        "family": None,
                        "given": None,
                        "address-city": city,
                        "address-postalcode": postal_code,
                        "_count": "10"
                    },
                    "medication": {
                        "search_type": None,
                        "query": None,
                        "limit": None
                    }
                },
                "reasoning": f"Fallback rule-based interpretation - detected specialty search for {found_specialty}"
            }
        
        # Check for actual practitioner names (only if no specialty found)
        name_patterns = [
            # Pattern 1: "Dr/Doctor + name" 
            r'\b(?:dr\.?|docteur|doctor)\s+([A-ZÁÉÈÊËÏÎÔÙÛÜŸÇ][a-záéèêëïîôùûüÿç\-]+(?:\s+[A-ZÁÉÈÊËÏÎÔÙÛÜŸÇ][a-záéèêëïîôùûüÿç\-]+)+)\b',
            # Pattern 2: Proper name pattern (capitalized first+last, not specialty terms) - exclude command words at start
            r'(?:find|search|cherche|show|get|pour|pour\s+un|looking\s+for)?\s*([A-ZÁÉÈÊËÏÎÔÙÛÜŸÇ][a-záéèêëïîôùûüÿç\-]+\s+[A-ZÁÉÈÊËÏÎÔÙÛÜŸÇ][A-ZÁÉÈÊËÏÎÔÙÛÜŸÇ\-]+)\b'
        ]
        
        practitioner_name = None
        for pattern in name_patterns:
            match = re.search(pattern, query, re.IGNORECASE)
            if match:
                raw_name = match.group(1).strip()
                # Exclude specialty keywords from being treated as names
                if not any(spec in raw_name.lower() for spec in specialty_keywords.keys()):
                    # Exclude common command words
                    if not any(word in raw_name.lower() for word in ['find', 'search', 'cherche', 'show', 'get']):
                        practitioner_name = raw_name.title()
                        break
        
        if practitioner_name:
            # Split name into family and given
            name_parts = practitioner_name.split()
            family_name = name_parts[-1] if name_parts else ""
            given_name = " ".join(name_parts[:-1]) if len(name_parts) > 1 else ""
            
            return {
                "intent": "practitioner",
                "confidence": 0.8,
                "extracted_entities": {
                    "entity_type": ["practitioner"],
                    "practitioner_name": practitioner_name,
                    "location": {
                        "city": city,
                        "postal_code": postal_code
                    }
                },
                "search_strategy": {
                    "primary": "practitioner",
                    "fallback": None,
                    "parallel": False
                },
                "fhir_params": {
                    "organization": {
                        "address-city": None,
                        "address-postalcode": None,
                        "_count": None
                    },
                    "practitioner": {
                        "practitioner_name": practitioner_name,
                        "name": practitioner_name,
                        "family": family_name,
                        "given": given_name,
                        "address-city": city,
                        "address-postalcode": postal_code,
                        "_count": "10"
                    },
                    "medication": {
                        "search_type": None,
                        "query": None,
                        "limit": None
                    }
                },
                "reasoning": f"Fallback rule-based interpretation - detected name search for {practitioner_name}"
            }
        
        # Default general search
        org_keywords = ["hospital", "hôpital", "clinic", "clinique", "cabinet", "centre", "center"]
        is_org_query = any(keyword in query_lower for keyword in org_keywords)
        intent = "organization" if is_org_query else "practitioner"
        
        return {
            "intent": intent,
            "confidence": 0.6,
            "extracted_entities": {
                "entity_type": ["organization"] if intent == "organization" else ["practitioner"],
                "location": {
                    "city": city,
                    "postal_code": postal_code
                }
            },
            "search_strategy": {
                "primary": intent,
                "fallback": None,
                "parallel": False
            },
            "fhir_params": {
                "organization": {
                    "address-city": city if intent == "organization" else None,
                    "address-postalcode": postal_code if intent == "organization" else None,
                    "_count": "10"
                },
                "practitioner": {
                    "address-city": city if intent == "practitioner" else None,
                    "address-postalcode": postal_code if intent == "practitioner" else None,
                    "_count": "10"
                },
                "medication": {
                    "search_type": None,
                    "query": None,
                    "limit": None
                }
            },
            "reasoning": f"Fallback rule-based interpretation - general {intent} search"
        }
    
    def synchronous_interpret_query(self, user_query: str) -> Dict[str, Any]:
        """Synchronous version using regular OpenAI client"""
        system_prompt = f"""You are an intelligent healthcare search interpreter for France. 
Your job is to analyze user queries and determine the best search strategy.

{self.fhir_context}

Analyze the user query and return a JSON response with this structure:
{{
    "intent": "organization" | "practitioner" | "medication" | "mixed",
    "confidence": 0.0-1.0,
    "extracted_entities": {{
        "entity_type": ["hospital", "clinic", "doctor", "specialist", "medication", "substance", etc.],
        "specialty": "extracted medical specialty if any",
        "location": {{
            "city": "city name if mentioned",
            "postal_code": "postal code if extractable",
            "arrondissement": "Paris arrondissement if mentioned"
        }},
        "organization_name": "specific name if mentioned",
        "practitioner_name": "specific name if mentioned",
        "medication_name": "medication name if mentioned",
        "substance_name": "active substance if mentioned",
        "cis_code": "CIS code if mentioned",
        "count": "number if user specified how many results"
    }},
    "search_strategy": {{
        "primary": "organization" | "practitioner" | "medication",
        "fallback": "organization" | "practitioner" | "medication" | null,
        "parallel": true | false
    }},
    "fhir_params": {{
        "organization": {{
            "name": "value or null",
            "address-city": "value or null", 
            "address-postalcode": "value or null",
            "_count": "number"
        }},
        "practitioner": {{
            "specialty": "value or null",
            "practitioner_name": "value or null",
            "name": "value or null", 
            "family": "value or null",
            "given": "value or null",
            "address-city": "value or null",
            "address-postalcode": "value or null", 
            "_count": "number"
        }},
        "medication": {{
            "search_type": "name" | "substance" | "cis_code",
            "query": "medication name, substance, or CIS code",
            "limit": "number of results"
        }}
    }},
    "reasoning": "Brief explanation of your interpretation"
}}

Handle French language naturally. Convert Paris arrondissements to postal codes.
Be intelligent about ambiguous queries - use context clues.
For name searches, extract the practitioner name and put it in the practitioner_name field.
"""

        try:
            response = self.openai_client.chat.completions.create(
                model="grok-2-1212",
                messages=[
                    {"role": "system", "content": system_prompt},
                    {"role": "user", "content": f"Query: {user_query}"}
                ],
                temperature=0.1,
                max_tokens=1000
            )
            
            result_text = response.choices[0].message.content
            
            # Parse the JSON response
            try:
                # Handle JSON wrapped in code blocks
                content = result_text.strip()
                if content.startswith('```json'):
                    # Extract JSON from code block
                    lines = content.split('\n')
                    json_lines = []
                    in_json = False
                    for line in lines:
                        if line.strip() == '```json':
                            in_json = True
                            continue
                        elif line.strip() == '```' and in_json:
                            break
                        elif in_json:
                            json_lines.append(line)
                    content = '\n'.join(json_lines)
                
                result = json.loads(content)
                print(f"[AI_DEBUG] Interpreted query: {user_query}")
                print(f"[AI_DEBUG] Result: {result}")
                return result
            except json.JSONDecodeError as e:
                print(f"[AI_ERROR] Failed to parse AI response: {e}")
                print(f"[AI_ERROR] Raw response: {result_text}")
                return self._fallback_interpretation(user_query)
                
        except Exception as e:
            print(f"[AI_ERROR] AI interpretation failed: {e}")
            return self._fallback_interpretation(user_query)
